q
num_indices
c
q
@queue
n
@queue
s
q
c
n
c
q
@key_position
n
@queue
n
s
n
@key_position
@queue
n
s
n
@key_position
@queue
n
s
q
@cache
c
q
@queue
n
s
c
q
@cache
q
@queue
s
q
key
@queue
c
@queue
@queue.length
n
q
@usage_order
@usage_values
@usage
@items
key
c
n
@items
n
@items
@usage
n
least_used_key
n
least_used_value
n
@usage
@items
value
key
s
q
str
j
str[i..j]
c
str[i..j]
c
str[i..j]
c
str[i..j]
c
str[i..j]
c
str[i..j]
c
i==j
i-j
j
i
str[i..j]
q
c
ret.map(&:length).sort.last
str
ret
q
str.slice(0, 1)
str.slice(0, 3)
str.slice(0, 2)
str
size
q
str
size
q
size
str.slice(pos, size)
s
q
(10..100).reverse_each
(10..100).reverse.to_a
(10..100).reverse.each.to_a
(10..100).each.to_a
(10..1).each.to_a
(10..1).to_a
size
str.slice(pos, size)
s
c
new_arr
q
new_arr
c
q
map_of_positions[char]
first_pos
max_size
str
char
index
c
n
c
q
first_pos
str
char
index
c
max_size
n
current_length
n
index
str
repeated_char_index
n
map_of_positions
index
c
q
map_of_positions
n
map_of_positions
n
map_of_positions
map_of_positions[char]
n
map_of_positions
map_of_positions[char]
n
map_of_positions
map_of_positions[char]
s
n
s
n
c
n
c
q
str.length
str
map_of_positions
first_pos
max_size
n
q
c
str.length
n
str
c
str
c
q
str
index
map_of_positions[char]
n
index
char
map_of_positions[char]
n
s
n
c
n
q
c
n
max_size
n
index
first_pos
char
str[first_pos]
c
q
n
carry
sum
n
s
n
q
c
q
n
s
occurrences
byebug
n
nums
target
c
indices
target
c
n
indices.slice(0, 2)
k == target - k
target
indices
k
s
n
s
c
n
s
n
c
n
q
target - k
nums[target - k]
nums[target - k].first
indices.first
indices
c
q
occurrences
n
